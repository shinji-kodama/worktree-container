package devcontainer

import (
	"encoding/json"
	"strings"
	"testing"

	"github.com/shinji-kodama/worktree-container/internal/model"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"gopkg.in/yaml.v3"
)

// --- GenerateComposeOverride tests ---

// TestGenerateComposeOverride_SingleService verifies that the generated Compose
// override YAML has the correct structure for a single-service configuration
// (Pattern C). It checks the project name, ports, and labels.
func TestGenerateComposeOverride_SingleService(t *testing.T) {
	portAllocations := []model.PortAllocation{
		{ServiceName: "app", ContainerPort: 3000, HostPort: 13000, Protocol: "tcp"},
		{ServiceName: "app", ContainerPort: 8080, HostPort: 18080, Protocol: "tcp"},
	}

	labels := map[string]string{
		"worktree.managed-by": "worktree-container",
		"worktree.name":       "feature-auth",
	}

	services := []string{"app"}

	// Act
	result, err := GenerateComposeOverride("feature-auth", services, portAllocations, labels)
	require.NoError(t, err, "GenerateComposeOverride should succeed for single service")

	// Assert: the output should start with the header comment.
	assert.True(t, strings.HasPrefix(string(result), "# Auto-generated by worktree-container"),
		"output should start with the auto-generated header comment")
	assert.Contains(t, string(result), "DO NOT EDIT",
		"output should contain the DO NOT EDIT warning")

	// Parse the YAML (skipping comment lines) to verify the structure.
	var override struct {
		Name     string `yaml:"name"`
		Services map[string]struct {
			Ports  []string          `yaml:"ports"`
			Labels map[string]string `yaml:"labels"`
		} `yaml:"services"`
	}
	err = yaml.Unmarshal(result, &override)
	require.NoError(t, err, "generated YAML should be valid")

	// Assert: top-level name sets the Compose project name.
	assert.Equal(t, "feature-auth", override.Name,
		"top-level name should be the environment name (used as COMPOSE_PROJECT_NAME)")

	// Assert: the app service exists with correct ports.
	appService, ok := override.Services["app"]
	require.True(t, ok, "services should contain 'app'")
	assert.Len(t, appService.Ports, 2, "app service should have 2 port mappings")
	assert.Contains(t, appService.Ports, "13000:3000",
		"should contain shifted port mapping for 3000")
	assert.Contains(t, appService.Ports, "18080:8080",
		"should contain shifted port mapping for 8080")

	// Assert: the app service has worktree labels.
	assert.Equal(t, "worktree-container", appService.Labels["worktree.managed-by"],
		"managed-by label should be present")
	assert.Equal(t, "feature-auth", appService.Labels["worktree.name"],
		"name label should be present")
}

// TestGenerateComposeOverride_MultiService verifies the Compose override YAML
// for a multi-service configuration (Pattern D) with three services: app, db,
// and redis. Each service should have its own port mappings and all services
// should have the worktree labels.
func TestGenerateComposeOverride_MultiService(t *testing.T) {
	portAllocations := []model.PortAllocation{
		{ServiceName: "app", ContainerPort: 3000, HostPort: 13000, Protocol: "tcp"},
		{ServiceName: "db", ContainerPort: 5432, HostPort: 15432, Protocol: "tcp"},
		{ServiceName: "redis", ContainerPort: 6379, HostPort: 16379, Protocol: "tcp"},
	}

	labels := map[string]string{
		"worktree.managed-by":     "worktree-container",
		"worktree.name":           "feature-multi",
		"worktree.config-pattern": "compose-multi",
	}

	services := []string{"app", "db", "redis"}

	// Act
	result, err := GenerateComposeOverride("feature-multi", services, portAllocations, labels)
	require.NoError(t, err)

	// Parse the YAML for assertion.
	var override struct {
		Name     string `yaml:"name"`
		Services map[string]struct {
			Ports  []string          `yaml:"ports"`
			Labels map[string]string `yaml:"labels"`
		} `yaml:"services"`
	}
	err = yaml.Unmarshal(result, &override)
	require.NoError(t, err)

	// Assert: all three services are present.
	require.Len(t, override.Services, 3,
		"should have exactly 3 services: app, db, redis")

	// Assert: app service has its port mapping.
	appService := override.Services["app"]
	require.Len(t, appService.Ports, 1)
	assert.Equal(t, "13000:3000", appService.Ports[0])

	// Assert: db service has its port mapping.
	dbService := override.Services["db"]
	require.Len(t, dbService.Ports, 1)
	assert.Equal(t, "15432:5432", dbService.Ports[0])

	// Assert: redis service has its port mapping.
	redisService := override.Services["redis"]
	require.Len(t, redisService.Ports, 1)
	assert.Equal(t, "16379:6379", redisService.Ports[0])

	// Assert: all services have the same set of worktree labels.
	for _, svcName := range services {
		svc := override.Services[svcName]
		assert.Equal(t, "worktree-container", svc.Labels["worktree.managed-by"],
			"service %s should have managed-by label", svcName)
		assert.Equal(t, "feature-multi", svc.Labels["worktree.name"],
			"service %s should have name label", svcName)
		assert.Equal(t, "compose-multi", svc.Labels["worktree.config-pattern"],
			"service %s should have config-pattern label", svcName)
	}
}

// TestGenerateComposeOverride_Labels verifies that ALL provided labels appear
// in the output YAML for every service. This test uses a comprehensive set of
// labels matching the full Docker label schema.
func TestGenerateComposeOverride_Labels(t *testing.T) {
	// Use a comprehensive label set matching what BuildLabels would produce.
	labels := map[string]string{
		"worktree.managed-by":     "worktree-container",
		"worktree.name":           "label-test",
		"worktree.branch":         "feature/labels",
		"worktree.worktree-path":  "/Users/user/project-label-test",
		"worktree.source-repo":    "/Users/user/project",
		"worktree.config-pattern": "compose-single",
		"worktree.created-at":     "2026-02-28T10:00:00Z",
	}

	services := []string{"app"}
	var portAllocations []model.PortAllocation // No ports needed for this test.

	// Act
	result, err := GenerateComposeOverride("label-test", services, portAllocations, labels)
	require.NoError(t, err)

	// Parse the YAML.
	var override struct {
		Services map[string]struct {
			Labels map[string]string `yaml:"labels"`
		} `yaml:"services"`
	}
	err = yaml.Unmarshal(result, &override)
	require.NoError(t, err)

	appService := override.Services["app"]

	// Assert: every label from the input is present in the output.
	for key, expectedValue := range labels {
		actualValue, exists := appService.Labels[key]
		assert.True(t, exists, "label %q should be present in the YAML output", key)
		assert.Equal(t, expectedValue, actualValue,
			"label %q value should match", key)
	}

	// Assert: no extra labels were added beyond what was provided.
	assert.Len(t, appService.Labels, len(labels),
		"should have exactly the same number of labels as provided")
}

// TestGenerateComposeOverride_ServiceWithoutPorts verifies that services without
// port allocations still appear in the override YAML with labels but no ports section.
func TestGenerateComposeOverride_ServiceWithoutPorts(t *testing.T) {
	// Only app has ports; worker has no ports.
	portAllocations := []model.PortAllocation{
		{ServiceName: "app", ContainerPort: 3000, HostPort: 13000, Protocol: "tcp"},
	}

	labels := map[string]string{
		"worktree.managed-by": "worktree-container",
		"worktree.name":       "mixed-ports",
	}

	services := []string{"app", "worker"}

	result, err := GenerateComposeOverride("mixed-ports", services, portAllocations, labels)
	require.NoError(t, err)

	var override struct {
		Services map[string]struct {
			Ports  []string          `yaml:"ports"`
			Labels map[string]string `yaml:"labels"`
		} `yaml:"services"`
	}
	err = yaml.Unmarshal(result, &override)
	require.NoError(t, err)

	// Assert: worker service exists with labels but no ports.
	workerService, ok := override.Services["worker"]
	require.True(t, ok, "worker service should be present even without ports")
	assert.Empty(t, workerService.Ports,
		"worker service should have no ports")
	assert.Equal(t, "worktree-container", workerService.Labels["worktree.managed-by"],
		"worker service should still have labels")
}

// --- RewriteComposeConfig tests ---

// TestRewriteComposeConfig verifies that the devcontainer.json is correctly
// rewritten for Compose patterns:
//  1. name → changed to envName
//  2. dockerComposeFile → override YAML path appended to the array
func TestRewriteComposeConfig(t *testing.T) {
	// Arrange: original devcontainer.json with a single Compose file.
	rawJSON := []byte(`{
		"name": "compose-app",
		"dockerComposeFile": "docker-compose.yml",
		"service": "app",
		"workspaceFolder": "/workspace"
	}`)

	// Act
	result, err := RewriteComposeConfig(rawJSON, "feature-compose", "docker-compose.worktree.yml")
	require.NoError(t, err)

	var resultMap map[string]interface{}
	err = json.Unmarshal(result, &resultMap)
	require.NoError(t, err)

	// Assert: name is changed.
	assert.Equal(t, "feature-compose", resultMap["name"],
		"name should be changed to the environment name")

	// Assert: dockerComposeFile is now an array with the override appended.
	composeFiles, ok := resultMap["dockerComposeFile"].([]interface{})
	require.True(t, ok, "dockerComposeFile should be an array")
	assert.Len(t, composeFiles, 2,
		"dockerComposeFile should have original + override")
	assert.Equal(t, "docker-compose.yml", composeFiles[0],
		"first entry should be the original compose file")
	assert.Equal(t, "docker-compose.worktree.yml", composeFiles[1],
		"second entry should be the override YAML (must be last for precedence)")

	// Assert: other fields are preserved.
	assert.Equal(t, "app", resultMap["service"],
		"service field should be preserved")
	assert.Equal(t, "/workspace", resultMap["workspaceFolder"],
		"workspaceFolder should be preserved")
}

// TestRewriteComposeConfig_ArrayDockerComposeFile verifies that RewriteComposeConfig
// correctly handles an already-array dockerComposeFile field.
func TestRewriteComposeConfig_ArrayDockerComposeFile(t *testing.T) {
	// Arrange: dockerComposeFile is already an array with two files.
	rawJSON := []byte(`{
		"name": "compose-multi",
		"dockerComposeFile": ["docker-compose.yml", "docker-compose.dev.yml"],
		"service": "app"
	}`)

	result, err := RewriteComposeConfig(rawJSON, "multi-env", "docker-compose.worktree.yml")
	require.NoError(t, err)

	var resultMap map[string]interface{}
	err = json.Unmarshal(result, &resultMap)
	require.NoError(t, err)

	// Assert: override is appended to the existing array.
	composeFiles, ok := resultMap["dockerComposeFile"].([]interface{})
	require.True(t, ok)
	assert.Len(t, composeFiles, 3,
		"should have both original files plus the override")
	assert.Equal(t, "docker-compose.yml", composeFiles[0])
	assert.Equal(t, "docker-compose.dev.yml", composeFiles[1])
	assert.Equal(t, "docker-compose.worktree.yml", composeFiles[2])
}

// TestRewriteComposeConfig_DuplicateOverridePrevented verifies that calling
// RewriteComposeConfig multiple times does not add duplicate override entries.
func TestRewriteComposeConfig_DuplicateOverridePrevented(t *testing.T) {
	// Arrange: dockerComposeFile already contains the override path.
	rawJSON := []byte(`{
		"name": "already-has-override",
		"dockerComposeFile": ["docker-compose.yml", "docker-compose.worktree.yml"],
		"service": "app"
	}`)

	result, err := RewriteComposeConfig(rawJSON, "dup-test", "docker-compose.worktree.yml")
	require.NoError(t, err)

	var resultMap map[string]interface{}
	err = json.Unmarshal(result, &resultMap)
	require.NoError(t, err)

	// Assert: override should NOT be duplicated.
	composeFiles, ok := resultMap["dockerComposeFile"].([]interface{})
	require.True(t, ok)
	assert.Len(t, composeFiles, 2,
		"should still have exactly 2 entries (no duplicate)")

	// Count occurrences of the override path.
	count := 0
	for _, f := range composeFiles {
		if s, ok := f.(string); ok && s == "docker-compose.worktree.yml" {
			count++
		}
	}
	assert.Equal(t, 1, count,
		"override path should appear exactly once")
}

// TestRewriteComposeConfig_PreservesJSONCComments verifies that JSONC comments
// in the input are stripped cleanly and the output is valid JSON.
func TestRewriteComposeConfig_PreservesJSONCComments(t *testing.T) {
	rawJSON := []byte(`{
		// This is a JSONC comment
		"name": "jsonc-test",
		/* Block comment */
		"dockerComposeFile": "docker-compose.yml",
		"service": "app"
	}`)

	result, err := RewriteComposeConfig(rawJSON, "jsonc-env", "docker-compose.worktree.yml")
	require.NoError(t, err)

	// The output should be valid JSON (no comments).
	var resultMap map[string]interface{}
	err = json.Unmarshal(result, &resultMap)
	require.NoError(t, err, "output should be valid JSON even if input had JSONC comments")

	assert.Equal(t, "jsonc-env", resultMap["name"])
}
